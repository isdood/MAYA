const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;
    const cwd = std.fs.cwd();

    // Define shader files to process
    const shader_files = [_]struct {
        name: []const u8,
        path: []const u8,
    }{
        .{ .name = "float", .path = "shaders/4d_tensor_operations_float.comp.spv" },
        .{ .name = "int", .path = "shaders/4d_tensor_operations_int.comp.spv" },
        .{ .name = "uint", .path = "shaders/4d_tensor_operations_uint.comp.spv" },
    };

    // Create output file
    const output_file = try cwd.createFile("src/vulkan/compute/shaders.zig", .{ .truncate = true });
    defer output_file.close();
    
    var writer = output_file.writer();
    
    // Write header
    try writer.writeAll(
        \\// This file is auto-generated by scripts/dump_shader.zig
        \\// Do not edit manually
        \\
        \\// 4D tensor operations shaders for different data types
        \\
    );

    // Process each shader file
    for (shader_files) |shader| {
        // Read shader file
        const shader_data = try cwd.readFileAlloc(allocator, shader.path, 10 * 1024 * 1024); // 10MB max
        defer allocator.free(shader_data);

        // Write shader array
        try writer.print("pub const {s} = [_]u8{{ ", .{shader.name});
        
        for (shader_data, 0..) |byte, i| {
            if (i > 0) try writer.writeAll(", ");
            if (i % 16 == 0) try writer.writeAll("\\n    ");
            try writer.print("0x{x:0>2}", .{byte});
        }
        
        try writer.writeAll(" };\n\n");
    }
}
