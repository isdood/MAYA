const std = @import("std");
const vk = @import("vulkan");

/// Compile a compute shader from GLSL to SPIR-V
pub fn compileShader(compiler: *std.Build.CompileStep, source_path: []const u8, output_path: []const u8) !void {
    // This function would use glslangValidator or another GLSL compiler
    // to compile the shader to SPIR-V
    // For now, we'll assume the shaders are pre-compiled
    _ = compiler;
    _ = source_path;
    _ = output_path;
    // TODO: Implement shader compilation
}

/// Load a pre-compiled SPIR-V shader
pub fn loadSpirvFromFile(allocator: std.mem.Allocator, path: []const u8) ![]u32 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();
    
    const size = (try file.stat()).size;
    if (size % @sizeOf(u32) != 0) {
        return error.InvalidSpirv;
    }
    
    const code = try allocator.alloc(u32, @divExact(size, @sizeOf(u32)));
    errdefer allocator.free(code);
    
    const bytes = std.mem.sliceAsBytes(code);
    const bytes_read = try file.readAll(bytes);
    if (bytes_read != bytes.len) {
        return error.ShortRead;
    }
    
    return code;
}

/// Convert a SPIR-V file to a Zig source file containing the SPIR-V as a constant
pub fn generateSpirvSource(allocator: std.mem.Allocator, input_path: []const u8, output_path: []const u8, function_name: []const u8) !void {
    const code = try loadSpirvFromFile(allocator, input_path);
    defer allocator.free(code);
    
    var output_file = try std.fs.cwd().createFile(output_path, .{});
    defer output_file.close();
    
    var writer = output_file.writer();
    
    try writer.print("// Auto-generated from {s}\n", .{std.fs.path.basename(input_path)});
    try writer.writeAll("// DO NOT EDIT THIS FILE DIRECTLY\n\n");
    
    try writer.print("pub fn {s}() callconv(.C) [*]const u32 {{\n", .{function_name});
    try writer.writeAll("    return &@as([*]const u32, @ptrCast(&[_]u32{\n");
    
    // Write the SPIR-V words in chunks of 8
    var i: usize = 0;
    while (i < code.len) : (i += 8) {
        try writer.writeAll("        ");
        const end = @min(i + 8, code.len);
        for (code[i..end]) |word| {
            try writer.print("0x{x8}, ", .{word});
        }
        try writer.writeAll("\n");
    }
    
    try writer.writeAll("    }))[0];\n");
    try writer.writeAll("}\n");
}

/// Create a shader module from SPIR-V code
pub fn createShaderModule(device: vk.VkDevice, code: []const u32) !vk.VkShaderModule {
    const create_info = vk.VkShaderModuleCreateInfo{
        .sType = vk.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        .pNext = null,
        .flags = 0,
        .codeSize = @sizeOf(u32) * code.len,
        .pCode = code.ptr,
    };
    
    var shader_module: vk.VkShaderModule = undefined;
    const result = vk.vkCreateShaderModule(device, &create_info, null, &shader_module);
    if (result != vk.VK_SUCCESS) {
        return error.FailedToCreateShaderModule;
    }
    
    return shader_module;
}
