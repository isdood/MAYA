@pattern_meta@
GLIMMER Pattern:
{
  "metadata": {
    "timestamp": "2025-06-16 08:36:04",
    "author": "isdood",
    "pattern_version": "1.0.0",
    "color": "#FF69B4"
  },
  "file_info": {
    "path": "./cursor-extension/node_modules/@typescript-eslint/typescript-estree/dist/simple-traverse.js",
    "type": "js",
    "hash": "99f4d1e85f1e3784e126cb0af1c8b84bf5b005e0"
  }
}
@pattern_meta@

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleTraverse = void 0;
const visitor_keys_1 = require("@typescript-eslint/visitor-keys");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isValidNode(x) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return x != null && typeof x === 'object' && typeof x.type === 'string';
}
function getVisitorKeysForNode(allVisitorKeys, node) {
    const keys = allVisitorKeys[node.type];
    return (keys !== null && keys !== void 0 ? keys : []);
}
class SimpleTraverser {
    constructor(selectors, setParentPointers = false) {
        this.allVisitorKeys = visitor_keys_1.visitorKeys;
        this.selectors = selectors;
        this.setParentPointers = setParentPointers;
    }
    traverse(node, parent) {
        if (!isValidNode(node)) {
            return;
        }
        if (this.setParentPointers) {
            node.parent = parent;
        }
        if ('enter' in this.selectors) {
            this.selectors.enter(node, parent);
        }
        else if (node.type in this.selectors) {
            this.selectors[node.type](node, parent);
        }
        const keys = getVisitorKeysForNode(this.allVisitorKeys, node);
        if (keys.length < 1) {
            return;
        }
        for (const key of keys) {
            const childOrChildren = node[key];
            if (Array.isArray(childOrChildren)) {
                for (const child of childOrChildren) {
                    this.traverse(child, node);
                }
            }
            else {
                this.traverse(childOrChildren, node);
            }
        }
    }
}
function simpleTraverse(startingNode, options, setParentPointers = false) {
    new SimpleTraverser(options, setParentPointers).traverse(startingNode, undefined);
}
exports.simpleTraverse = simpleTraverse;
//# sourceMappingURL=simple-traverse.js.map